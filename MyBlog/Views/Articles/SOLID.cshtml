
@{
    ViewData["Title"] = "SOLID";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="container articles">
    <p>
        Herkese merhaba, bugünki yazımızda yazılım geliştirirken kullanılan çok önemli bir prensip olan <b>SOLID</b> den  bahsedeceğiz. SOLID standart yazılım geliştirmede kullanılması elzem olan bir prensiptir.
        Standart derken neyi kastediyoruz? Yazılımın belli bir çerçevede olmasını, herkes tarafınca kolayca anlaşılmasını belli bir kalıba yazılımımızın oturması gerektiğini kastediyourz. Yani yazdığımız kodu çevremizdekilerde anlasın, kurumsal firmalarda anlasın hatta dünyadaki bir yazılım geliştiricide kolayca anlasın demek.<br /><br /> Peki SOLID ismi nerden geliyor? 5 tane ana prensibin baş harflerinin birleştirilmesiyle oluşmuştur. Peki bu 5 prensip nedir, şimdi de onlara bakalım.
        <br /><br />
        1-) <b>S</b>ingle Responsibility Principle
        <br />
        2-) <b>O</b>pen-Closed Principle
        <br />
        3-) <b>L</b>iskov's Substitution Principle
        <br />
        4-) <b>I</b>nterface Segregation Principle
        <br />
        5-) <b>D</b>ependency Inversion Principle
        <br /><br />
        Şimdi gelelim bu 5 prensip nedir? Bizler için neler ifade ediyor?
        <br /><br />
        
        <h4>Single Responsibility Principle</h4>
        
        <p>
            SOLID'in S harfine karşılık gelen Single Responsibility Principle yani tek sorumluluk prensibi derki; bir metot yalnızca kendisine verilen işi yapmalıdır. Projelerimizde metotları fazlasıyla kullanırız. Kullandığımız her metodun sadece bir görevi olmalıdır. Bir metot birden fazla işi yerine getirmemelidir. Örnek vermek gerekirse metot hem veritabanına kayıt işlemini yerine getirip hemde mesela bir matematiksel işlem yapmamalıdır. Peki yapsak ne olur? Bir metotun birden fazla işi görmesinin ne zararı olur ki? Bir kere kodun okunabilirliği azalır. Alakalı alakasız her şey iç içe olur en önemlisi projeye yeni eklemeler yaptığımız zaman acaba bu eklemelerden neler etkilenecek düşüncesinden sıyrılmış oluruz çünkü zaten bizim işlerimizi yerine getiren metotlarımız birbirinden ayrıdır. Hepsi birbirinden ayrı olduğu için nelerin değişebileceğini görmekte oldukça kolay. 
        </p>
    <br />
    <h4>Open-Closed Principle</h4>
    <p>
        Bu prensip ise projemizdeki nesnelerin gelişime açık ama değişime kapalı olduğunu anlatır. Bir class oluşturmuşuzdur, zamanla ihtiyaçlar değişmiştir bu classa yada metotlarıma yeni eklemeler yapıp var olanı genişletip geliştirebiliriz ama classı komple değiştirmeye kapalı olmalıyız. Bu değişimden etkilenecek nesnelerimizide düşündüğümüz zaman işimizin çok fazla zorlaşıp karmaşıklaşacağıda net şekilde belli olmaktadır.
    </p>
    <br />
    <h4>Liskov's Substitution Principle</h4>
    <p>Yerine geçme prensibine göre kalıtım alan sınıf kalıtım aldığı nesnenin tüm özelliklerini kullanmalıdır bu özelliklere ek olarak kendi özelliklerine ekleyebilir. Buradaki amaç ise şudur; kalıtım alırken zaten kod fazlalığının önüne geçip okunabilirliği ve performansı arttırmaya çalışıyoruz eğer kalıtım alan sınıf kalıtım aldığı sınıftan yani atasından gelen özellikleri kullanmazsa gereksiz kodlar fazlalaşır ve kalıtım almanın amacına ters düşer böylece kodun verimliliği azalır.</p>
    <br />
    <h4>Interface Segregation Principle</h4>
    <p>SOLID'ın bu prensibi interface kullanımı ile alakalıdır. Buradaki amaç bir interface gerektiğinde fazla özelliğe sahip olmamalıdır. Her bir interface belirli bir amaca sahip olmalıdır. Mesela bir Müşteri sınıfımızın birde Ürün sınıfımızın olduğunu varsayalım. İki sınıfta kendine ait bazı özelliklere sahiptir. Eğer biz bütün operasyonları iki ayrı intreface yerine tek interface de toplarsak hem Müşteri hemde Ürün sınıfı bu interface içerisindeki metotları uygulamak zorunda kalırlar. İşte burada iki ayrı interface oluşturup her interface in kendine özgü işlemleri yerine getirmesini sağlamalıyız.</p>
    <br />
    <h4>Dependency Inversion Principle</h4>
    <p>Gelelim son maddemiz olan bağımlılığın ters çevrilmesi ilkesine. Bu prensip derki üst sınıflarımız alt sınıflara bağlı olmamalıdır. Aralarındaki ilişki soyutlama ile yani abstraction yada interface ile sağlanmalıdır çünkü soyutlama yapmazsak alt sınıflarda yada üst sınıflarda yapılan bir değişiklik tüm bağantılı sınıfları etkileyeceği için işin içinden çıkılamaz bir hal alabilir. </p>
    </div>
